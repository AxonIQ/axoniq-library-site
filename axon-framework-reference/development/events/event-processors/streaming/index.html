<!DOCTYPE html>
<html lang="en">
  <head>
        <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Streaming Event Processor</title>
    <link rel="canonical" href="https://docs.axoniq.io/axon-framework-reference/5.0/events/event-processors/streaming/">
    <link rel="prev" href="../subscribing/">
    <link rel="next" href="../dead-letter-queue/">
    <meta name="generator" content="Antora 3.1.10">
    <link rel="stylesheet" href="../../../../../_/css/site.css">
    <link rel="stylesheet" href="../../../../../_/css/vendor/tabs.css">
    <link rel="icon" href="../../../../../_/img/favicon.png" sizes="32x32">
    <link rel="apple-touch-icon" href="../../../../../_/img/favicon.png"><!-- 180Ã—180 -->
    <link rel="manifest" href="../../../../../_/static/manifest.webmanifest">

        <!-- Google Tag Manager -->
        <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-5QD58ZB');</script>
        <!-- End Google Tag Manager -->

    <script>var uiRootPath = '../../../../../_'</script>


<link rel="icon" href="../../../../../_/img/favicon.png" type="image/png">
  </head>
  <body class="article">
    <div class="header_container">
      
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5QD58ZB"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://docs.axoniq.io">
        <img src="../../../../../_/img/docs-logo.png" class="header_logo"/>
      </a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-center">
        <a class="navbar-item" href="../../../../../home/basics/">Basics</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="../../../../../home/guides/">Guides</a>
          <div class="navbar-dropdown card">
            <a class="navbar-item" href="../../../../../home/guides/axon-framework">Axon Framework</a>
            <a class="navbar-item" href="../../../../../home/guides/axon-server">Axon Server</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="../../../../../home/reference/">Reference</a>
          <div class="navbar-dropdown card">
                <a class="navbar-item" href="../../../../5.0/">Axon Framework</a>
                <a class="navbar-item" href="../../../../../axon-framework-extensions/">Axon Framework Extensions</a>
                <a class="navbar-item" href="../../../../../axon-server-reference/development/">Axon Server</a>
                <a class="navbar-item" href="../../../../../synapse-reference/v0.12/">Axon Synapse</a>
                <a class="navbar-item" href="../../../../../axoniq-platform-reference/">Axoniq Platform</a>
          </div>
        </div>
      </div>
      <div class="navbar-end">
          <div class="navbar-item search hide-for-print">
            <div id="search-field" class="field">
              <input id="search-input" type="text" placeholder="Search AxonIQ Docs">
            </div>
          </div>
        <a class="navbar-item navbar-button" href="https://platform.axoniq.io" target="_blank">Axoniq Platform</a>
      </div>
    </div>
  </nav>
</header>
      <div class="toolbar card" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../../../home/" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../../">Axon Framework Reference</a></li>
    <li><a href="../../">Events</a></li>
    <li><a href="../">Event Processors</a></li>
    <li><a href="./">Streaming Event Processor</a></li>
  </ul>
</nav>
<div class="page-actions">
  <button class="actions-menu-toggle" title="Show actions related to this page">Actions</button>
  <div class="actions-menu toolbar_dropdown_menu card">
      <a class="action item" href="https://github.com/AxonFramework/AxonFramework/edit/main/docs/reference-guide/modules/events/pages/event-processors/streaming.adoc">Edit this Page</a>
    
    <a class="action item" href="https://discuss.axoniq.io/search?q&#x3D;Streaming%20Event%20Processor" target="discuss_search">View Discussions</a>
    <a class="action item" href="https://discuss.axoniq.io/new-topic?category&#x3D;library&amp;title&#x3D;%22Streaming%20Event%20Processor%22%20Discussion&amp;body&#x3D;%3C!--%20Replace%20this%20comment%20with%20your%20comment%2Fsuggestion%2Fquestion%2F...%20--%3E%0A%0A%0A%3C!--%0AKeep%20the%20section%20below!%0ALinking%20back%20to%20the%20documentation%20URL%20not%20only%20helps%20people%20go%20to%20the%20page%0Abut%20also%20helps%20find%20relevant%20discussions%20from%20the%20documentation%20page%20via%20the%20%22View%20Discussion%22%20menu.%0A--%3E%0A%5Bdetails%3D%22Related%20library%20page%22%5D%0A%5BStreaming%20Event%20Processor%5D(https%3A%2F%2Fdocs.axoniq.io%2Faxon-framework-reference%2Fdevelopment%2Fevents%2Fevent-processors%2Fstreaming%2F)%0A%5B%2Fdetails%5D%0A" target="discuss_add">Start new discussion</a>
  </div>
</div>


<div class="page-versions">
  <button class="version-menu-toggle" title="Show other versions of page">development</button>
  <div class="version-menu toolbar_dropdown_menu card">
    <a class="version item is-current" href="./">development</a>
    <a class="version item" href="../../../../5.0/events/event-processors/streaming/">5.0</a>
    <a class="version item" href="../../../../4.12/events/event-processors/streaming/">4.12</a>
    <a class="version item" href="../../../../4.11/events/event-processors/streaming/">4.11</a>
    <a class="version item" href="../../../../4.10/events/event-processors/streaming/">4.10</a>
    <a class="version item is-missing" href="../../../../0/">older releases</a>
  </div>
</div>
</div>
    </div>
    <div class="content_container">
      <div class="body">
<div class="nav-container" data-component="axon-framework-reference" data-version="development">
    <aside class="nav card">
      <div class="panels">
        <div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../../">Axon Framework</a></h3>

<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../../">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../../migration/">Migration Guide</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../migration/why-upgrade/">Why Upgrade?</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../migration/prerequisites/">Prerequisites</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../migration/solved-architecture-choices/">Resolved Problems</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../migration/understanding-architecture-principles/">Understanding Choices</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../../messaging-concepts/">Messaging Concepts</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../messaging-concepts/anatomy-message/">Anatomy of a Message</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../messaging-concepts/message-intercepting/">Message Intercepting</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../messaging-concepts/supported-parameters-annotated-handlers/">Supported Parameters for Annotated Handlers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../messaging-concepts/message-correlation/">Message Correlation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../messaging-concepts/exception-handling/">Exception Handling</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../messaging-concepts/processing-context/">Processing Context</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../../commands/">Commands</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../commands/command-handlers/">Handling</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../commands/command-dispatchers/">Dispatching</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../commands/infrastructure/">Infrastructure</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../commands/configuration/">Configuration</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../">Events</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../event-handlers/">Handling</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../event-publishing/">Publishing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../">Event Processors</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../subscribing/">Subscribing Event Processor</a>
  </li>
  <li class="nav-item is-current-page" data-depth="3">
    <a class="nav-link" href="./">Streaming Event Processor</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../dead-letter-queue/">Dead-Letter Queue</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../infrastructure/">Infrastructure</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../event-store-internals/">Event Store Internals</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../event-versioning/">Versioning</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../../queries/">Queries</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../queries/query-handlers/">Handling</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../queries/query-dispatchers/">Dispatching</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../queries/infrastructure/">Infrastructure</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../queries/configuration/">Configuration</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../../testing/">Testing</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../testing/basic-testing/">Basic Testing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../testing/matchers-and-field-filters/">Matchers and Field Filters</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../testing/advanced-testing/">Advanced Testing</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../../conversion/">Conversion</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../../tuning/">Tuning</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../tuning/event-snapshots/">Event Snapshots</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../tuning/event-processing/">Event Processing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../tuning/command-processing/">Command Processing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../tuning/rdbms-tuning/">Relational Databases</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../../monitoring/">Monitoring</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../monitoring/tracing/">Tracing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../monitoring/metrics/">Metrics</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../monitoring/health/">Health Indicators</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../monitoring/processors/">Event Processor Monitoring</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../monitoring/message-tracking/">Message Tracking</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../../spring-boot-integration/">Spring Boot Integration</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../../modules/">Modules</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../../release-notes/">Release Notes</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../release-notes/major-releases/">Major Releases</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../release-notes/minor-releases/">Minor Releases</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../../known-issues-and-workarounds/">Known Issues and Workarounds</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
      </div>
    </aside>
</div>
<main class="article">
    <div class="page_content">
        <aside class="toc sidebar" data-title="Page content" data-levels="2">
  <div class="toc-menu"></div>
</aside>
          <article class="doc">
                <h1 class="page">Streaming Event Processor</h1>
            <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The <code>StreamingEventProcessor</code>, or Streaming Processor for short, is a type of <a href="../" class="xref page">Event Processor</a>.
As any Event Processor, it serves as the technical aspect to handle events by invoking the event handlers written in an Axon application.</p>
</div>
<div class="paragraph">
<p>The Streaming Processor defines itself by receiving the events from a <code>StreamableEventSource</code>.
The <code>StreamableEventSource</code> is an infrastructure component through which we can open a stream of events.
The source can also specify positions on the event stream, so-called <a href="#tracking_tokens">Tracking Tokens</a>, used as start positions when opening an event stream.
An example of a <code>StreamableEventSource</code> is the <a href="../../infrastructure/#event_store" class="xref page"><code>EventStore</code></a>, like for example Axon Server or the <a href="../../infrastructure/#aggregatebasedjpaeventstorageengine" class="xref page">JPA aggregate-based storage engine</a>.</p>
</div>
<div class="paragraph">
<p>Furthermore, Streaming Processors use separate threads to process the events retrieved from the <code>StreamableEventSource</code>.
Using separate threads decouples the <code>StreamingEventProcessor</code> from other operations (for example, event publication or command handling), allowing for cleaner separation within any application.
Using separate threads allows for <a href="#parallel_processing">parallelization</a> of the event load, either within a single JVM or between several.</p>
</div>
<div class="paragraph">
<p>When starting a Streaming Processor, it will open an event stream through the configured <code>StreamableEventSource</code>.
The first time a stream has started, it, by default, will begin at the <strong>first</strong> position (the oldest token) of the stream.
It keeps track of the event processing progress while traversing the stream.
It does so by storing the Tracking Tokens, or <em>tokens</em> for short, accompanying the events.
This solution works towards tracking the progress since the tokens specify the event&#8217;s position on the stream.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">First or latest?</div>
<div class="paragraph">
<p>The first, or oldest, token is located at the beginning of the stream, and the newest, or latest, token is positioned at the tip of the stream.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Maintaining the progress through tokens makes a Streaming Processor</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>able to deal with stopping and starting the processor,</p>
</li>
<li>
<p>more resilient against unintended shutdowns, and</p>
</li>
<li>
<p>the token provides a means to <a href="#replaying-events">replay</a> events by adjusting the position of tokens.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>All combined, the Streaming Processor allows for decoupling, parallelization, resiliency, and replay-ability.
It is these features that make the Streaming Processor the logical choice for the majority of applications.
Due to this, the "Pooled Streaming Event Processor," a type of Streaming Processor, is the default Event Processor.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Default Event Processor</div>
<div class="paragraph">
<p>Which <code>EventProcessor</code> type becomes the default processor depends on the event source available in your application.
In the majority of use cases, an Event Store is present.
As the Event Store is a type of <code>StreamableEventSource</code>, the default will be the Pooled Streaming Event Processor.</p>
</div>
<div class="paragraph">
<p>If the application only has an Event Bus configured, the framework will lack a <code>StreamableEventSource</code>.
It will fall back to the <a href="../subscribing/" class="xref page">Subscribing Event Processor</a> as the default in these scenarios.
This implementation will use the configured <code>EventBus</code> as its <code>SubscribableMessageSource</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The Pooled Streaming Event Processor (PSEP for short) is the recommended processor implementation for most users.
It provides a high-performance, two-pool architecture that separates event fetching from event processing, enabling efficient parallel processing and better resource utilization.</p>
</div>
<div class="paragraph">
<p>The processor supports all core streaming operations including <a href="#replaying-events">replaying events</a>, <a href="#parallel_processing">parallelism</a>, and tracking progress with <a href="#tracking_tokens">tokens</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuring"><a class="anchor" href="#configuring"></a>Configuring</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Pooled Streaming Event Processor has several additional components that you can configure, next to the <a href="../#general_processor_configuration" class="xref page">base options</a>.
For other features that are configurable, we refer to their respective sections for more details.
This section covers how to configure the basics of a Pooled Streaming Event Processor.</p>
</div>
<div class="paragraph">
<p>To configure a Pooled Streaming Event Processor you have roughly two approaches:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#declarative_config_pooled">Declarative configuration</a></p>
</li>
<li>
<p><a href="#autodetected_config_spring_properties_pooled">Autodetected configuration</a>, like Spring</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Both solutions have examples drafted below, showing how to configure the "example-processor" with a specific event source.</p>
</div>
<div class="sect2">
<h3 id="declarative_config_pooled"><a class="anchor" href="#declarative_config_pooled"></a>Declarative configuration</h3>
<div class="paragraph">
<p>When using Axon&#8217;s configuration API, you should invoke the <code>MessagingConfigurer#eventProcessing(Consumer&lt;EventProcessingConfigurer&gt;)</code> operation.
The <code>EventProcessingConfigurer</code> lambda guides users towards:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>First, selecting the Event Processor type,</p>
</li>
<li>
<p>second, register a lambda to retrieve the Event Handling Components, and,</p>
</li>
<li>
<p>third, customization for the event processor, if any.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The example below shows how this approach is used to define a (1) <code>PooledStreamingEventProcessor</code> with the (2) <code>AnnotatedEventHandlingClass</code> as the single event handling component, and (3) with a specific customization:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.eventhandling.configuration.EventHandlingComponentsConfigurer;
import org.axonframework.messaging.eventhandling.processing.streaming.pooled.PooledStreamingEventProcessorsConfigurer;
import org.axonframework.messaging.eventstreaming.StreamableEventSource;

public class AxonConfig {

    public void configureEventProcessing(MessagingConfigurer configurer) {
        configurer.eventProcessing(eventConfigurer -&gt; eventConfigurer.pooledStreaming(
                this::configurePooledStreamingProcessor
        ));
    }

    private PooledStreamingEventProcessorsConfigurer configurePooledStreamingProcessor(
            PooledStreamingEventProcessorsConfigurer pooledStreamingConfigurer
    ) {
        return pooledStreamingConfigurer.processor(
                "example-processor",
                config -&gt; config.eventHandlingComponents(this::configureHandlingComponent)
                                .notCustomized()
        );
    }

    private EventHandlingComponentsConfigurer.AdditionalComponentPhase configureHandlingComponent(
            EventHandlingComponentsConfigurer.RequiredComponentPhase componentConfigurer
    ) {
        return componentConfigurer.autodetected(c -&gt; new AnnotatedEventHandlingClass());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above shows how to configure "example-processor" as a Pooled Streaming Event Processor.
When no customization is required, the <code>customized</code> method can be replaced by the <code>notCustomized()</code> operation.</p>
</div>
<div class="paragraph">
<p>If you prefer to define defaults for all Pooled Streaming Processors, you can use the <code>defaults(&#8230;&#8203;)</code> instead of <code>customized(&#8230;&#8203;)</code>.
This does not limit to possibility to override defaults, as is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.eventhandling.configuration.EventHandlingComponentsConfigurer;
import org.axonframework.messaging.eventhandling.processing.streaming.pooled.PooledStreamingEventProcessorsConfigurer;
import org.axonframework.messaging.eventstreaming.StreamableEventSource;

import java.time.Duration;

public class AxonConfig {

    public void configureEventProcessing(MessagingConfigurer configurer) {
        configurer.eventProcessing(eventConfigurer -&gt; eventConfigurer.pooledStreaming(
                this::configurePooledStreamingProcessor
        ));
    }

    private PooledStreamingEventProcessorsConfigurer configurePooledStreamingProcessor(
            PooledStreamingEventProcessorsConfigurer pooledStreamingConfigurer
    ) {
        return pooledStreamingConfigurer
                // Set defaults for all pooled streaming processors
                .defaults((config, processorConfig) -&gt; processorConfig
                        .eventSource(config.getComponent(StreamableEventSource.class))
                        .segmentCount(4)
                        .batchSize(100)
                        .claimExtensionThreshold(Duration.ofSeconds(5))
                )
                // Configure a specific processor
                .processor(
                        "example-processor",
                        config -&gt; config.eventHandlingComponents(this::configureHandlingComponent)
                                        .customize((c, pooledStreamingConfig) -&gt; pooledStreamingConfig
                                                .segmentCount(8)  // Override default for this processor
                                        )
                );
    }

    private EventHandlingComponentsConfigurer.AdditionalComponentPhase configureHandlingComponent(
            EventHandlingComponentsConfigurer.RequiredComponentPhase componentConfigurer
    ) {
        return componentConfigurer.autodetected(c -&gt; new AnnotatedEventHandlingClass());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="autodetected_config_spring_properties_pooled"><a class="anchor" href="#autodetected_config_spring_properties_pooled"></a>Autodetected configuration - Spring Boot properties file</h3>
<div class="paragraph">
<p>A properties file allows the configuration of several fields for the Pooled Streaming Event Processor.
If more flexibility is required, like concretely defining the event handling components to attach, we recommend use of the <a href="#declarative_config_pooled">declarative configuration</a> instead.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">axon.eventhandling.processors.example-processor.mode=pooled-streaming
axon.eventhandling.processors.example-processor.source=eventStore
axon.eventhandling.processors.example-processor.initial-segment-count=4
axon.eventhandling.processors.example-processor.batch-size=100</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the name of an event processor contains periods <code>.</code>, use the map notation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">axon.eventhandling.processors[example.processor].mode=pooled-streaming
axon.eventhandling.processors[example.processor].source=eventStore</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="error_mode"><a class="anchor" href="#error_mode"></a>Error mode</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Whenever the <a href="../#error-handling" class="xref page">error handler</a> rethrows an exception, the <code>PooledStreamingEventProcessor</code> aborts the failed processing segment.</p>
</div>
<div class="paragraph">
<p>The processor will retry processing using an incremental back-off period, starting at 1 second and doubling after each attempt until it reaches the maximum wait time of 60 seconds per attempt.</p>
</div>
<div class="paragraph">
<p>Due to the <a href="#Pooled streaming processor threading">two-pool threading architecture</a>, the failed segment is likely to be picked up quickly by another thread within the same JVM.
The back-off mechanism applies within the local JVM instance only.</p>
</div>
<div class="paragraph">
<p>In a distributed environment with multiple PSEP instances, other instances will ignore the back-off and may immediately claim and process the failed segment, providing faster recovery from transient errors.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tracking_tokens"><a class="anchor" href="#tracking_tokens"></a>Tracking tokens</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A vital attribute of the Streaming Event Processor is its capability to keep and maintain the processing progress.
It does so through the <code>TrackingToken</code>, the "token" for short.
Such a token accompanies each message a streaming processor receives through its event stream.
It&#8217;s this token that:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>specifies the position of the event on the overall stream, and</p>
</li>
<li>
<p>is used by the Streaming Processor to open the event stream at the desired position on start-up.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Using tokens gives the Streaming Event Processor several benefits, like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Being able to reopen the stream at any later point, picking up where it left off with the last event.</p>
</li>
<li>
<p>Dealing with unintended shutdowns without losing track of the last events they&#8217;ve handled.</p>
</li>
<li>
<p>Collaboration over the event handling load from two perspectives.
First, the tokens make sure only a single thread is actively processing specific events.
Secondly, it allows <a href="#parallel_processing">parallelization</a> of the load over several threads or nodes of a Streaming Processor.</p>
</li>
<li>
<p><a href="#replaying-events">Replaying</a> events by adjusting the token position of that processor.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To be able to reopen the stream at a later point, we should keep the progress somewhere.
The progress is kept by updating and saving the <code>TrackingToken</code> after handling batches of events.
Keeping the progress requires CRUD operation, for which the Streaming Processor uses the <a href="#token_store"><code>TokenStore</code></a>.</p>
</div>
<div class="paragraph">
<p>For a Streaming Processor to process any events, it needs <a href="#token_claim_config">"a claim"</a> on a <code>TrackingToken</code>.
The processor will update this claim every time it has finished handling a batch of events.
This so-called "claim extension" is, just as updating and saving of tokens, delegated to the Token Store.
Hence, the Streaming Processors achieves collaboration among instances/threads through token claims.</p>
</div>
<div class="paragraph">
<p>In the absence of a claim, a processor will actively try to retrieve one.
If a token claim is not extended for a configurable amount of time, other processor threads can <a href="#token_stealing">"steal"</a> the claim.
Token stealing can, for example, happen if event processing is slow or encountered some exceptions.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Easy TrackingToken access</div>
<div class="paragraph">
<p>When processing an event, it may be beneficial to retrieve the token belonging to that event.
First, this can be achieved by adding a parameter of type <code>TrackingToken</code> to the event handler.
This support is mentioned in the <a href="../../../messaging-concepts/supported-parameters-annotated-handlers/#supported-parameters-for-event-handlers" class="xref page">Supported Parameters for Event Handlers</a> section.</p>
</div>
<div class="paragraph">
<p>Additionally, you can retrieve the token from the resources collection of the <a href="../../../messaging-concepts/processing-context/" class="xref page">Processing Context</a>.
To that end, the <code>TrackingToken</code> interface has the static <code>fromContext(Context)</code> operation, which can ingest the <code>ProcessingContext</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="initial_token"><a class="anchor" href="#initial_token"></a>Initial tracking token</h3>
<div class="paragraph">
<p>The Streaming Processor uses a <code>StreamableEventSource</code> to retrieve a stream of events that will open on start-up.
It requires a <code>TrackingToken</code> to open this stream, which it will fetch from the <code>TokenStore</code>.
However, if a Streaming Processor starts for the first time, there is no <code>TrackingToken</code> present to open the stream with yet.</p>
</div>
<div class="paragraph">
<p>Whenever this situation occurs, a Streaming Processor will construct an "initial token." By default, the initial token will start at the first position of the event stream.
Thus, the processor will begin at the start and handle every event present in the event source.
This start position is configurable, as is described <a href="#token_configuration">here</a>.</p>
</div>
<div class="paragraph">
<p>Conceptually, there are a couple of scenarios when a processor builds an initial token on application startup.
The obvious one is already shared, namely when a processor starts for the first time.
There are, however, also other situations when a token is built that might be unexpected, like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>TokenStore</code> has (accidentally) been cleared between application runs, thus losing the stored tokens.</p>
</li>
<li>
<p>The application running the processor starts in a new environment (for example, test or acceptance) for the first time.</p>
</li>
<li>
<p>An <code>InMemoryTokenStore</code> was used, and hence the processor could never persist the token to begin with.</p>
</li>
<li>
<p>The application is (accidentally) pointing to another storage solution than expected.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Whenever a Streaming Processor&#8217;s event handlers show unexpected behavior in the form of missed or reprocessed events, a new initial token might have been triggered.
In those cases, we recommend to validate if any of the above situations occurred.</p>
</div>
</div>
<div class="sect2">
<h3 id="token_configuration"><a class="anchor" href="#token_configuration"></a>Token configuration</h3>
<div class="paragraph">
<p>There are a couple of things we can configure when it comes to tokens.
We can separate these options in "initial token" and "token claim" configuration, as described in the following sections:</p>
</div>
<div class="sect3">
<h4 id="initial_token_config"><a class="anchor" href="#initial_token_config"></a>Initial token</h4>
<div class="paragraph">
<p>The <a href="#initial_token">initial token</a> for a <code>StreamingEventProcessor</code> is configurable for every processor instance.
When configuring the initial token builder function, the received input parameter is the <code>StreamableEventSource</code>.
The event source provides methods to build a token:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>firstToken()</code>: Creates a token at the first position of the source.</p>
</li>
<li>
<p><code>latestToken()</code>: Creates a token at the latest position of the source.</p>
</li>
<li>
<p><code>tokenAt(Instant)</code>: Creates a token at a specific point in time.
If there is an event precisely at that given moment, it will also be included.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Of course, you can completely disregard the <code>StreamableEventSource</code> input parameter and create a token by yourself.
This will, for example, allow you to use predefined token positions like:
- <code>TrackingToken.FIRST</code>: Start from the beginning of the stream.
- <code>TrackingToken.LATEST</code>: Start from the latest position, processing only new events.
Consider the following snippets if you want to configure a different initial token:</p>
</div>
<div id="_tabs_1" class="openblock tabs is-loading">
<div class="content">
<div class="ulist tablist">
<ul>
<li id="_tabs_1_configuration_api" class="tab">
<p>Configuration API</p>
</li>
<li id="_tabs_1_spring_boot" class="tab">
<p>Spring Boot</p>
</li>
</ul>
</div>
<div id="_tabs_1_configuration_api--panel" class="tabpanel" aria-labelledby="_tabs_1_configuration_api">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.eventhandling.configuration.EventHandlingComponentsConfigurer;
import org.axonframework.messaging.eventhandling.processing.streaming.pooled.PooledStreamingEventProcessorsConfigurer;

public class AxonConfig {

    public void configureEventProcessing(MessagingConfigurer configurer) {
        configurer.eventProcessing(eventConfigurer -&gt; eventConfigurer.pooledStreaming(
                this::configureInitialToken
        ));
    }

    private PooledStreamingEventProcessorsConfigurer configureInitialToken(
            PooledStreamingEventProcessorsConfigurer pooledStreamingConfigurer
    ) {
        return pooledStreamingConfigurer.processor(
                "example-processor",
                config -&gt; config.eventHandlingComponents(this::configureHandlingComponent)
                                .customized((c, pooledStreamingConfig) -&gt; pooledStreamingConfig.initialToken(
                                        source -&gt; source.firstToken(null)
                                ))
        );
    }
}</code></pre>
</div>
</div>
</div>
<div id="_tabs_1_spring_boot--panel" class="tabpanel" aria-labelledby="_tabs_1_spring_boot">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// TODO #4053 - Introduce Event Processor Specification bean example.</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="token_claim_config"><a class="anchor" href="#token_claim_config"></a>Token claims</h4>
<div class="paragraph">
<p>As described <a href="#tracking_tokens">here</a>, a streaming processor should claim a token before it is allowed to perform any processing work.
There are several scenarios where a processor may keep the claim for too long.
This can occur when, for example, the event handling process is slow or encountered an exception.</p>
</div>
<div class="paragraph">
<p>In those scenarios, another processor can steal a token claim to proceed with processing.
There are a couple of configurable values that influence this process:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>tokenClaimInterval</code>: Defines how long to wait between attempts to claim a segment.
A processor uses this value to steal token claims from other processor threads.
This value defaults to 5000 milliseconds.</p>
</li>
<li>
<p><code>claimExtensionThreshold</code>: Threshold to extend the claim in the absence of events.
The value defaults to 5000 milliseconds.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider the following snippet if you want to configure these values:</p>
</div>
<div id="_tabs_2" class="openblock tabs is-loading">
<div class="content">
<div class="ulist tablist">
<ul>
<li id="_tabs_2_configuration_api" class="tab">
<p>Configuration API</p>
</li>
<li id="_tabs_2_spring_boot" class="tab">
<p>Spring Boot</p>
</li>
</ul>
</div>
<div id="_tabs_2_configuration_api--panel" class="tabpanel" aria-labelledby="_tabs_2_configuration_api">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.eventhandling.configuration.EventHandlingComponentsConfigurer;
import org.axonframework.messaging.eventhandling.processing.streaming.pooled.PooledStreamingEventProcessorsConfigurer;

public class AxonConfig {

    public void configureEventProcessing(MessagingConfigurer configurer) {
        configurer.eventProcessing(eventConfigurer -&gt; eventConfigurer.pooledStreaming(
                this::configureTokenClaims
        ));
    }

    private PooledStreamingEventProcessorsConfigurer configureTokenClaims(
            PooledStreamingEventProcessorsConfigurer pooledStreamingConfigurer
    ) {
        return pooledStreamingConfigurer.processor(
                "example-processor",
                config -&gt; config.eventHandlingComponents(this::configureHandlingComponent).customized(
                        (c, pooledStreamingConfig) -&gt; pooledStreamingConfig.claimExtensionThreshold(2500)
                                                                           .tokenClaimInterval(7500)
                )
        );
    }
}</code></pre>
</div>
</div>
</div>
<div id="_tabs_2_spring_boot--panel" class="tabpanel" aria-labelledby="_tabs_2_spring_boot">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// TODO #4053 - Introduce Event Processor Specification bean example.</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="token_stealing"><a class="anchor" href="#token_stealing"></a>Token stealing</h3>
<div class="paragraph">
<p>As described at the <a href="#tracking_tokens">start</a>, streaming processor threads can "steal" tokens from one another.
A token is "stolen" when a thread loses a <a href="#token_claim_config">token claim</a>.
Situations like this internally result in an <code>UnableToClaimTokenException,</code> caught by both streaming event processor implementations and translated into warn- or info-level log statements.</p>
</div>
<div class="paragraph">
<p>Where the framework uses token claims to ensure that a single thread is processing a sequence of events, it supports token stealing to guarantee event processing is not blocked forever.
In short, the framework uses token stealing to unblock your streaming processor threads when processing takes too long.
Examples may include literal slow processing, blocking exceptional scenarios, and deadlocks.</p>
</div>
<div class="paragraph">
<p>However, token stealing may occur as a surprise for some applications, making it an unwanted side effect.
As such, it is good to be aware of why tokens get stolen (as described above), but also when this happens and what the consequences are.</p>
</div>
<div class="sect3">
<h4 id="_when_is_a_token_stolen"><a class="anchor" href="#_when_is_a_token_stolen"></a>When is a token stolen?</h4>
<div class="paragraph">
<p>In practical terms, a token is stolen whenever the <em>claim timeout</em> is exceeded.</p>
</div>
<div class="paragraph">
<p>This timeout is met whenever the token&#8217;s timestamp (for example, the <code>timestamp</code> column of your <code>token_entry</code> table) exceeds the <code>claimTimeout</code> of the <code>TokenStore</code>.
By default, the <code>claimTimeout</code> value equals 10 seconds.
To adjust it, you must configure a <code>TokenStore</code> instance through its builder, as shown in the <a href="#token_store">Token Store</a> section.
If you use Spring Boot, you can alternatively set the <code>axon.eventhandling.tokenstore.claim-timeout</code> for example to <code>30s</code> to increase it to 30 seconds.</p>
</div>
<div class="paragraph">
<p>The token&#8217;s timestamp is equally crucial in deciding when the timeout is met.
The streaming processor thread holding the claim is in charge of updating the token timestamp.
This timestamp is updated whenever the thread finishes a batch of events or whenever the processor extends the claim based on the configured <code>claimExtensionThreshold</code>.
You should check out the <a href="#token_claim_config">token claim</a> section if you want to know how to configure these values.</p>
</div>
<div class="paragraph">
<p>To further clarify, a streaming processor&#8217;s thread needs to be able to update the token claim and, by extension, the timestamp to ensure it won&#8217;t get stolen.
Hence, a staling processor thread will, one way or another, eventually lose the claim.</p>
</div>
<div class="paragraph">
<p>Examples of when a thread may get its token stolen are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Overall slow event handling.</p>
</li>
<li>
<p>Too large event batch size.</p>
</li>
<li>
<p>Blocking operations inside event handlers.</p>
</li>
<li>
<p>Blocking exceptions inside event handlers.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_what_are_the_consequences_of_token_stealing"><a class="anchor" href="#_what_are_the_consequences_of_token_stealing"></a>What are the consequences of token stealing?</h4>
<div class="paragraph">
<p>The consequence of token stealing is that an event may be handled twice (or more).</p>
</div>
<div class="paragraph">
<p>When a thread steals a token, the original thread was <em>already</em> processing events from the token&#8217;s position.
To protect against doubling event handling, Axon Framework will combine committing the event handling task with updating the token.
As the token claim is required to update the token, the original thread will fail the update.
Following this, a rollback occurs on the <a href="../../../messaging-concepts/processing-context/" class="xref page">processing context</a>, resolving most issues arising from token stealing.</p>
</div>
<div class="paragraph">
<p>The ability to rollback event handling tasks sheds light on the consequences of token stealing.
Most event processors project events into a projection stored within a database.
Furthermore, if you store the projection in the same database as the token, the rollback will ensure the change is not persisted.
Thus, the consequence of token stealing is limited to wasting processor cycles.
This scenario is why we recommend storing tokens and projections in the same database.</p>
</div>
<div class="paragraph">
<p>If a rollback is out of the question for an event handling task, we strongly recommend making the task idempotent.
You may have this scenario when, for example, the projection and tokens do not reside in the same database.
Or, when the event handler dispatches an operation (for example, through the <code>CommandGateway</code>).
In making the invoked operation idempotent, you ensure that whenever the thread stealing a token handles an event twice (or more), the outcome will be identical.</p>
</div>
<div class="paragraph">
<p>Without idempotency, the consequences of token stealing can be many fold:
- Your projection (stored in a different database than your tokens!) may incorrectly project the state.
- An event handler putting messages on a queue will put a message on the queue again.
- A automation supporting Event Handler invoking a third-party service will invoke that service again.
- An event handler sending an email will send that email again.</p>
</div>
<div class="paragraph">
<p>In short, any operation introducing a side effect that isn&#8217;t handled in an idempotent fashion will occur again when a token is stolen.</p>
</div>
<div class="paragraph">
<p>Concluding, we can separate the consequence of token stealing into roughly three scenarios:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>We can roll back the operation.
In this case, the only consequence is wasted processor cycles.</p>
</li>
<li>
<p>The operation is idempotent.
In this case, the only consequence is wasted processor cycles.</p>
</li>
<li>
<p>When the task cannot be rolled back nor performed in an idempotent fashion, compensating actions are the way out.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="token_store"><a class="anchor" href="#token_store"></a>Token store</h3>
<div class="paragraph">
<p>The <code>TokenStore</code> provides asynchronous CRUD-styled operations for the <code>StreamingEventProcessor</code> to interact with <code>TrackingTokens</code>.
The streaming processor will use the store to construct, fetch, and claim tokens.</p>
</div>
<div class="paragraph">
<p>When no token store is explicitly defined, an <code>InMemoryTokenStore</code> is used.
The <code>InMemoryTokenStore</code> is <em>not</em> recommended in most production scenarios since it cannot maintain the progress through application shutdowns.
Unintentionally using the <code>InMemoryTokenStore</code> counts towards one of the unexpected scenarios where the framework creates an <a href="#initial_token">initial token</a> on each application start-up.</p>
</div>
<div class="paragraph">
<p>The framework provides a couple of <code>TokenStore</code> implementations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>InMemoryTokenStore</code> - A <code>TokenStore</code> implementation that keeps the tokens in memory.
This implementation does not suffice as a production-ready store in most applications.</p>
</li>
<li>
<p><code>JpaTokenStore</code> - A <code>TokenStore</code> implementation using JPA to store the tokens with.
Expects that a table is constructed based on the <code>org.axonframework.eventhandling.tokenstore.jpa.TokenEntry</code>.
It is easily auto-configurable with, for example, Spring Boot.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Keep your tokens close</div>
<div class="paragraph">
<p>Where possible, we recommend using a token store that stores tokens in the same database as to where the event handlers update the view models.
This way, changes to the view model can be stored atomically with the changed tokens.
Furthermore, it guarantees <strong>exactly once</strong> processing semantics.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that you can configure the token store to use for a streaming processor in the <code>EventProcessingConfigurer</code>:</p>
</div>
<div id="_tabs_3" class="openblock tabs is-loading">
<div class="content">
<div class="ulist tablist">
<ul>
<li id="_tabs_3_configuration_api" class="tab">
<p>Configuration API</p>
</li>
<li id="_tabs_3_spring_boot" class="tab">
<p>Spring Boot</p>
</li>
</ul>
</div>
<div id="_tabs_3_configuration_api--panel" class="tabpanel" aria-labelledby="_tabs_3_configuration_api">
<div class="paragraph">
<p>To configure a <code>TokenStore</code> for all processors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.eventhandling.configuration.EventHandlingComponentsConfigurer;
import org.axonframework.messaging.eventhandling.processing.streaming.pooled.PooledStreamingEventProcessorsConfigurer;
import org.axonframework.messaging.eventhandling.processing.streaming.token.store.TokenStore;

public class AxonConfig {

    public void configureEventProcessing(MessagingConfigurer configurer) {
        configurer.eventProcessing(eventConfigurer -&gt; eventConfigurer.pooledStreaming(
                this::configurePooledStreamingProcessor
        ));
    }

    private PooledStreamingEventProcessorsConfigurer configurePooledStreamingProcessor(
            PooledStreamingEventProcessorsConfigurer pooledStreamingConfigurer
    ) {
        return pooledStreamingConfigurer.processor(
                "example-processor",
                config -&gt; config.eventHandlingComponents(this::configureHandlingComponent)
                                .notCustomized()
        ).defaults((config, psepConfig) -&gt; psepConfig.tokenStore(
                config.getComponent(TokenStore.class)
        ));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, to configure a <code>TokenStore</code> for a specific processor, use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.eventhandling.configuration.EventHandlingComponentsConfigurer;
import org.axonframework.messaging.eventhandling.processing.streaming.pooled.PooledStreamingEventProcessorsConfigurer;
import org.axonframework.messaging.eventhandling.processing.streaming.token.store.TokenStore;

public class AxonConfig {

    public void configureEventProcessing(MessagingConfigurer configurer) {
        configurer.eventProcessing(eventConfigurer -&gt; eventConfigurer.pooledStreaming(
                this::configurePooledStreamingProcessor
        ));
    }

    private PooledStreamingEventProcessorsConfigurer configurePooledStreamingProcessor(
            PooledStreamingEventProcessorsConfigurer pooledStreamingConfigurer
    ) {
        return pooledStreamingConfigurer.processor(
                "example-processor",
                config -&gt; config.eventHandlingComponents(this::configureHandlingComponent)
                                .customized((c, psepConfig) -&gt; psepConfig.tokenStore(
                                        c.getComponent(TokenStore.class)
                                ))
        );
    }
}</code></pre>
</div>
</div>
</div>
<div id="_tabs_3_spring_boot--panel" class="tabpanel" aria-labelledby="_tabs_3_spring_boot">
<div class="paragraph">
<p>The default <code>TokenStore</code> implementation is defined based on dependencies available in Spring Boot, in the following order:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If any <code>TokenStore</code> bean is defined, that bean is used.</p>
</li>
<li>
<p>Otherwise, if an <code>EntityManager</code> is available, the <code>JpaTokenStore</code> is defined.</p>
</li>
<li>
<p>Lastly, the <code>InMemoryTokenStore</code> is used.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To override the TokenStore, either define a bean in a Spring <code>@Configuration</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.axonframework.messaging.eventhandling.processing.streaming.token.store.TokenStore;
import org.axonframework.messaging.eventhandling.processing.streaming.token.store.jpa.JpaTokenStore;
import org.axonframework.messaging.eventhandling.processing.streaming.token.store.jpa.JpaTokenStoreConfiguration;

@Configuration
public class AxonConfig {

    @Bean
    public TokenStore customTokenStore(EntityManagerProvider entityManagerProvider,
                                       Converter converter) {
        return new JpaTokenStore(entityManagerProvider, converter, JpaTokenStoreConfiguration.DEFAULT);
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_retrieving_the_token_store_identifier"><a class="anchor" href="#_retrieving_the_token_store_identifier"></a>Retrieving the token store identifier</h4>
<div class="paragraph">
<p>Implementations of <code>TokenStore</code> might share state in the underlying storage.
To ensure correct operation, a token store has a unique identifier that uniquely identifies the storage location of the tokens in that store.
This identifier can be queried with the <code>retrieveStorageIdentifier</code> method of your event processor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.axonframework.messaging.eventhandling.processing.streaming.StreamingEventProcessor;

public class AxonConfig {

    public String tokenStoreFor(StreamingEventProcessor eventProcessor) {
        return eventProcessor.getTokenStoreIdentifier();
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="parallel_processing"><a class="anchor" href="#parallel_processing"></a>Parallel processing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Streaming processors can use <a href="#thread_configuration">multiple threads</a> to process an event stream.
Using multiple threads allows the <code>StreamingEventProcessor</code> to more efficiently process batches of events.
As described <a href="#tracking_tokens">here</a>, a streaming processor&#8217;s thread requires a claim on a tracking token to process events.</p>
</div>
<div class="paragraph">
<p>Thus, to be able to parallelize the load, we require several tokens per processor.
To that end, each token instance represents a <em>segment</em> of the event stream, wherein each segment is identified through a number.
The stream segmentation approach ensures events aren&#8217;t handled twice (or more), as that would otherwise introduce unintentional duplication.
Due to this, the Streaming Processor&#8217;s API references segment claims instead of token claims throughout.</p>
</div>
<div class="paragraph">
<p>You can define the number of segments used by adjusting the <code>initialSegmentCount</code> property.
Only when a streaming processor starts for the first time can it initialize the number of segments to use.
This requirement follows from the fact each token represents a single segment.
Tokens, in turn, can only be initialized if they are not present yet, as is explained in more detail <a href="#initial_token">here</a>.</p>
</div>
<div class="paragraph">
<p>Whenever the number of segments should be adjusted during runtime, you can use the <a href="#splitting_and_merging_segments">split and merge</a> functionality.
To adjust the number of initial segments, consider the following sample:</p>
</div>
<div id="_tabs_4" class="openblock tabs is-loading">
<div class="content">
<div class="ulist tablist">
<ul>
<li id="_tabs_4_configuration_api" class="tab">
<p>Configuration API</p>
</li>
<li id="_tabs_4_spring_boot" class="tab">
<p>Spring Boot</p>
</li>
<li id="_tabs_4_spring_boot_properties" class="tab">
<p>Spring Boot properties</p>
</li>
</ul>
</div>
<div id="_tabs_4_configuration_api--panel" class="tabpanel" aria-labelledby="_tabs_4_configuration_api">
<div class="paragraph">
<p>The default number of segments for a <code>PooledStreamingEventProcessor</code> is sixteen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.eventhandling.configuration.EventHandlingComponentsConfigurer;
import org.axonframework.messaging.eventhandling.processing.streaming.pooled.PooledStreamingEventProcessorsConfigurer;

public class AxonConfig {

    public void configureEventProcessing(MessagingConfigurer configurer) {
        configurer.eventProcessing(eventConfigurer -&gt; eventConfigurer.pooledStreaming(
                this::configurePooledStreamingProcessor
        ));
    }

    private PooledStreamingEventProcessorsConfigurer configurePooledStreamingProcessor(
            PooledStreamingEventProcessorsConfigurer pooledStreamingConfigurer
    ) {
        return pooledStreamingConfigurer.processor(
                "example-processor",
                config -&gt; config.eventHandlingComponents(this::configureHandlingComponent)
                                .customized((c, psepConfig) -&gt; psepConfig.initialSegmentCount(32))
        );
    }
}</code></pre>
</div>
</div>
</div>
<div id="_tabs_4_spring_boot--panel" class="tabpanel" aria-labelledby="_tabs_4_spring_boot">
<div class="paragraph">
<p>The default number of segments for the <code>PooledStreamingEventProcessor</code> is sixteen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// TODO #4053 - Introduce Event Processor Specification bean example.</code></pre>
</div>
</div>
</div>
<div id="_tabs_4_spring_boot_properties--panel" class="tabpanel" aria-labelledby="_tabs_4_spring_boot_properties">
<div class="paragraph">
<p>The default number of segments for a <code>PooledStreamingEventProcessor</code> is sixteen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">axon.eventhandling.processors.example-processor.mode=pooled-streaming
# Sets the initial number of segments
axon.eventhandling.processors.example-processor.initial-segment-count=32</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Parallel Processing and Subscribing Event Processors</div>
<div class="paragraph">
<p>Note that <a href="../subscribing/" class="xref page">Subscribing Event Processors</a> don&#8217;t manage their own threads.
The only means to achieve this, is through a <code>SubscribableEventSource</code> that manages sequencing and threading for you.
An example of this is the <a href="../subscribing/#persistent_streams" class="xref page">persistent stream</a> functionality.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The Event Handling Components a processor is in charge of may have specific expectations on the event order.
The ordering is guaranteed when only a single thread is processing events.
Maintaining the ordering requires additional work when the stream is segmented for parallel processing, however.
When this is the case, the processor must ensure it sends the events to these handlers in that specific order.</p>
</div>
<div class="paragraph">
<p>Axon uses the <code>SequencingPolicy</code> for this.
The <code>SequencingPolicy</code> is a function that returns a value for any given message.
If the return value of the <code>SequencingPolicy</code> function is equal for two distinct event messages, it means that those messages must be processed sequentially.</p>
</div>
<div class="paragraph">
<p>Each node running a streaming processor will attempt to start its configured amount of threads to start processing events.
The pooled streaming processor uses a two-pool architecture where coordinator threads can claim multiple segments, and worker threads process the events from those segments.
This architecture provides efficient resource utilization and better scalability compared to a one-thread-per-segment model.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Customize your Sequencing Policy!</div>
<div class="paragraph">
<p>We strongly recommend to define a sequencing policy that fits your event handling components at all time!
As explaining <a href="#sequencing_policies">here</a>, it ensures your processes handle events in the desired order.
Furthermore, it increases the overall performance of your event processor if you have set the correct policy.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="sequential_processing"><a class="anchor" href="#sequential_processing"></a>Sequential processing</h3>
<div class="paragraph">
<p>Even though events are processed asynchronously from their publisher, it is often desirable to process certain events in their publishing order.
In Axon, the <code>SequencingPolicy</code> controls this order.
The <code>SequencingPolicy</code> defines whether events must be handled sequentially, in parallel, or a combination of both.
Policies return a sequence identifier of a given event.</p>
</div>
<div class="paragraph">
<p>If the policy returns the <em>same</em> identifier for two events, they must be handled sequentially by the Event Handling Component.
Thus, if the <code>SequencingPolicy</code> returns a <em>different</em> value for two events, they may be processed concurrently.
Note that if the policy returns an <code>Optional#empty</code> as the sequence identifier, the event may be processed in parallel with <em>any</em> other events.</p>
</div>
<div class="paragraph">
<p>By default, a <code>HierarchicalSequencingPolicy</code> is configured, which first tries for the <code>SequentialPerAggregatePolicy</code>.
If that fails, because the events don&#8217;t contain events, it falls back to the <code>SequentialPolicy</code>.
This policy handles events in the order they&#8217;ve been published within a <strong>single</strong> segment, thus eliminating any possibility for parallel processing.</p>
</div>
<div class="paragraph">
<p>As correctly sequencing your events is important for any application, we <strong>highly</strong> recommend you check out the <a href="#sequential_processing">sequential processing</a> section to understand how to configure a policy that fits with your application.
Furthermore, as defining the right policy will allow for parallel processing, it will (greatly) impact event processing performance.</p>
</div>
<div class="paragraph">
<p>Lastly, the sequencing policy may be configured for a <strong>single</strong> event handler or an <strong>entire</strong> event handling component.
In most cases, defining the policy for an entire event handling component is the way to go.
Scenarios where per-event-handler sequencing policies are required are, for example, event handling components reading events from several sources with differing identifiers in the events.
For the policies Axon provides out of the box and how to configure them, we recommend you read the following <a href="#sequencing_policies">section</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="sequencing_policies"><a class="anchor" href="#sequencing_policies"></a>The SequencingPolicy interface and annotation</h3>
<div class="paragraph">
<p>Conceptually, the <code>SequencingPolicy</code> decides whether an event belongs to a given <a href="#parallel_processing">segment</a>.
From there, Axon guarantees that Events that are part of the same segment are processed sequentially.</p>
</div>
<div class="paragraph">
<p>The framework provides several policies you can use out of the box:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PropertySequencingPolicy</code>: When configuring this policy, the user is required to provide a property name or property extractor function.
This implementation provides a flexible solution to set up a custom sequencing policy based on a standard value present in your events.
Note that this policy only reacts to properties present in the event class.</p>
</li>
<li>
<p><code>MetadataSequencingPolicy</code>: When configuring this policy, the user is required to provide a <code>metaDataKey</code> to be used.
This implementation provides a flexible solution to set up a custom sequencing policy based on a standard value present in your events' metadata.</p>
</li>
<li>
<p><code>SequentialPerAggregatePolicy</code>: The policy that forces events raised from the same aggregate / entity to be handled sequentially.
Thus, events from different entities may be handled concurrently.
This policy is typically suitable for Event Handling Components that update details from aggregates in databases.
Note this policy can only be used <strong>if</strong> an aggregate-based <a href="../../infrastructure/#event_storage_engine" class="xref page">event storage engine</a> is used!
If that is the case, Axon defaults to this policy for users.</p>
</li>
<li>
<p><code>FullConcurrencyPolicy</code>: This policy will tell Axon that this Event Processor may handle all events concurrently.
This means that there is no relationship between the events that require them to be processed in a particular order.</p>
</li>
<li>
<p><code>SequentialPolicy</code>: This policy tells Axon that it can process all events sequentially.
Handling of an event will start when the handling of a previous event has finished.
This is the default policy in Axon.</p>
</li>
<li>
<p><code>HierarchicalSequencingPolicy</code>: This policy allows you to form a hierarchy of policies that will work together.
The primary policy will be invoked first.
If the returned <code>Optional</code> is empty, it falls back to the secondary policy.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You have a number of options to configure a sequencing policy:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use the <code>@SequencingPolicy</code> on the <code>class</code> of your Event Handling Component.
This requires the autodetected configuration solution, is provided through Spring!</p>
</li>
<li>
<p>Use the <code>@SequencingPolicy</code> on the methods annotated with <code>@EventHandler</code>.
This requires the autodetected configuration solution, is provided through Spring!</p>
</li>
<li>
<p>Define the desired <code>SequencingPolicy</code> through declarative configuration with the <code>EventProcessingConfigurer</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Consider the following snippets when using the <code>@SequencingPolicy</code> annotation:</p>
</div>
<div id="_tabs_5" class="openblock tabs is-loading">
<div class="content">
<div class="ulist tablist">
<ul>
<li id="_tabs_5_sequencingpolicy_on_an_event_handling_component" class="tab">
<p>@SequencingPolicy on an Event Handling Component</p>
</li>
<li id="_tabs_5_sequencingpolicy_on_an_event_handler" class="tab">
<p>@SequencingPolicy on an Event Handler</p>
</li>
</ul>
</div>
<div id="_tabs_5_sequencingpolicy_on_an_event_handling_component--panel" class="tabpanel" aria-labelledby="_tabs_5_sequencingpolicy_on_an_event_handling_component">
<div class="paragraph">
<p>The <code>@SequencingPolicy</code> annotation has two parameters to provide:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The <code>class</code> of the <code>SequencingPolicy</code> to use.
This can be any of the described option above as well as a custom <code>SequencingPolicy</code>.</p>
</li>
<li>
<p>The <code>parameters</code> required to construct the <code>SequencingPolicy</code> type provided earlier.
Can be left empty when none are required.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If the constructor of the <code>SequencingPolicy</code> is a <code>class</code>, the resolution logic will insert the class of the first parameter of each event handler in the event handling component!
Hence, for the <code>PropertySequencingPolicy</code>, you are able to omit the first parameter of the constructor, as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.axonframework.messaging.eventhandling.annotation.EventHandler;
import org.axonframework.messaging.eventhandling.annotation.SequencingPolicy;
import org.axonframework.messaging.eventhandling.sequencing.PropertySequencingPolicy;

@SequencingPolicy(type = PropertySequencingPolicy.class, parameters = {"studentId"})
class CustomEventHandlingComponent {

    @EventHandler
    public void handle(StudentEnrolledEvent event) {
        // Handler logic
    }
}</code></pre>
</div>
</div>
</div>
<div id="_tabs_5_sequencingpolicy_on_an_event_handler--panel" class="tabpanel" aria-labelledby="_tabs_5_sequencingpolicy_on_an_event_handler">
<div class="paragraph">
<p>The <code>@SequencingPolicy</code> annotation has two parameters to provide:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The <code>class</code> of the <code>SequencingPolicy</code> to use.
This can be any of the described option above as well as a custom <code>SequencingPolicy</code>.</p>
</li>
<li>
<p>The <code>parameters</code> required to construct the <code>SequencingPolicy</code> type provided earlier.
Can be left empty when none are required.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If the constructor of the <code>SequencingPolicy</code> is a <code>class</code>, the resolution logic will insert the class of the first parameter of each event handler in the event handling component!
Hence, for the <code>PropertySequencingPolicy</code>, you are able to omit the first parameter of the constructor, as shown below:</p>
</div>
<div class="paragraph">
<p>Using the @SequencingPolicy on an event handler will <strong>at all times</strong> override the class-level sequencing policy configuration.
Thus, if you have an Event Handling Component with a <code>@SequencingPolicy</code> on the class, one on the event handler will override the sequencing behavior for that event handler specifically.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.axonframework.messaging.eventhandling.annotation.EventHandler;
import org.axonframework.messaging.eventhandling.annotation.SequencingPolicy;
import org.axonframework.messaging.eventhandling.sequencing.PropertySequencingPolicy;

@SequencingPolicy(type = PropertySequencingPolicy.class, parameters = {"studentId"})
class CustomEventHandlingComponent {

    @EventHandler
    @SequencingPolicy(type = PropertySequencingPolicy.class, parameters = {"courseId"})
    public void handle(CourseCreatedEvent event) {
        // Handler logic
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Consider the following snippets when configuring a (custom) <code>SequencingPolicy</code>:</p>
</div>
<div id="_tabs_6" class="openblock tabs is-loading">
<div class="content">
<div class="ulist tablist">
<ul>
<li id="_tabs_6_declarative_sequencing_policy_configuration" class="tab">
<p>Declarative Sequencing Policy configuration</p>
</li>
<li id="_tabs_6_autodetected_sequencing_policy_configuration_spring_boot" class="tab">
<p>Autodetected Sequencing Policy configuration - Spring Boot</p>
</li>
<li id="_tabs_6_autodetected_sequencing_policy_configuration_spring_boot_properties" class="tab">
<p>Autodetected Sequencing Policy configuration - Spring Boot properties</p>
</li>
</ul>
</div>
<div id="_tabs_6_declarative_sequencing_policy_configuration--panel" class="tabpanel" aria-labelledby="_tabs_6_declarative_sequencing_policy_configuration">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.axonframework.messaging.core.MessageStream;
import org.axonframework.messaging.core.QualifiedName;
import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.eventhandling.EventHandlingComponent;
import org.axonframework.messaging.eventhandling.SimpleEventHandlingComponent;
import org.axonframework.messaging.eventhandling.configuration.EventHandlingComponentsConfigurer;
import org.axonframework.messaging.eventhandling.processing.streaming.pooled.PooledStreamingEventProcessorsConfigurer;
import org.axonframework.messaging.eventhandling.sequencing.PropertySequencingPolicy;

public class AxonConfig {

    public void configureEventProcessing(MessagingConfigurer configurer) {
        configurer.eventProcessing(eventConfigurer -&gt; eventConfigurer.pooledStreaming(
                this::configurePooledStreamingProcessor
        ));
    }

    private PooledStreamingEventProcessorsConfigurer configurePooledStreamingProcessor(
            PooledStreamingEventProcessorsConfigurer pooledStreamingConfigurer
    ) {
        return pooledStreamingConfigurer.processor(
                "example-processor",
                config -&gt; config.eventHandlingComponents(this::configureHandlingComponent).notCustomized()
        );
    }

    private EventHandlingComponentsConfigurer.AdditionalComponentPhase configureHandlingComponent(
            EventHandlingComponentsConfigurer.RequiredComponentPhase componentConfigurer
    ) {
        return componentConfigurer.declarative(c -&gt; {
            PropertySequencingPolicy&lt;BaseEvent, Object&gt; policy =
                    new PropertySequencingPolicy&lt;&gt;(BaseEvent.class, "identifier");

            EventHandlingComponent eventHandlingComponent = new SimpleEventHandlingComponent(policy);
            eventHandlingComponent.subscribe(
                    new QualifiedName("test-event"),
                    (event, context) -&gt; {
                        // process events
                        return MessageStream.empty();
                    }
                    );
            return eventHandlingComponent;
        });
    }
}</code></pre>
</div>
</div>
</div>
<div id="_tabs_6_autodetected_sequencing_policy_configuration_spring_boot--panel" class="tabpanel" aria-labelledby="_tabs_6_autodetected_sequencing_policy_configuration_spring_boot">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// TODO #4053 - Introduce Event Processor Specification bean example.</code></pre>
</div>
</div>
</div>
<div id="_tabs_6_autodetected_sequencing_policy_configuration_spring_boot_properties--panel" class="tabpanel" aria-labelledby="_tabs_6_autodetected_sequencing_policy_configuration_spring_boot_properties">
<div class="paragraph">
<p>When we want to configure the <code>SequencingPolicy</code> in a properties file, we should provide a bean name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">axon.eventhandling.processors.example-processor.mode=tracking
axon.eventhandling.processors.example-processor.sequencing-policy=customSequencingPolicy</code></pre>
</div>
</div>
<div class="paragraph">
<p>This approach does require the bean name to be present in the Application Context of course:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class AxonConfig {
    // omitting other configuration methods...
    @Bean
    public SequencingPolicy&lt;EventMessage&lt;?&gt;&gt; customSequencingPolicy() {
        return new FullConcurrencyPolicy();
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the available policies do not suffice, you can define your own.
To that end, we should implement the <code>SequencingPolicy</code> interface.
This interface defines a single method, <code>getSequenceIdentifierFor(EventMessage, ProcessingContext)</code>, that returns an <code>Optional</code> of the sequence identifier for the given event and context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface SequencingPolicy {

    Optional&lt;Object&gt; getSequenceIdentifierFor(EventMessage event, ProcessingContext context);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="thread_configuration"><a class="anchor" href="#thread_configuration"></a>Thread configuration</h3>
<div class="paragraph">
<p>A Streaming Processor cannot process events in parallel without multiple threads configured.
We can process events in parallel by running <a href="#multi_node_processing">several nodes</a> of an application.
Or by configuring a <code>StreamingEventProcessor</code> to use several threads.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Thread and Segment Count</div>
<div class="paragraph">
<p>Adjusting the number of threads will not automatically parallelize a Streaming Processor.
A segment claim <a href="#parallel_processing">is required</a> to let a thread process any events.
Added, the used <a href="#sequencing_policies">sequencing policy</a> will also impact how events are spread over the segments.
Hence, increasing the thread count should be paired with adjusting the segment count and ensuring the right sequencing policy is used.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>PooledStreamingEventProcessor</code> uses a two-pool thread architecture, separating event fetching from event processing for better resource utilization and scalability.
The first thread pool is in charge of opening a stream with the event source, claiming as <em>many</em> segments as possible, and delegating all the work.</p>
</div>
<div class="paragraph">
<p>The work it coordinates is foremost the events to handle.
Next to event coordination, it deals with segment operations like <a href="#splitting_and_merging_segments">split and merge</a>.
The component coordinating all the work is called the <code>Coordinator</code>.
This coordinator defaults to using a <code>ScheduledExecutorService</code> with a single thread, which suffices in most scenarios.</p>
</div>
<div class="paragraph">
<p>The second thread pool deals with all the segments the <code>Coordinator</code> of the pooled streaming processor could claim.
The <code>Coordinator</code> starts a <code>WorkPackage</code> for each segment and provides them the events to handle.
The work package will, in turn, invoke the Event Handling Components to process the events.
These packages run within the second thread pool, the so-called "worker executor" pool.
The worker-pool also defaults to <code>ScheduledExecutorService</code> with a single thread.</p>
</div>
<div class="paragraph">
<p>When you want to increase event handling throughput, we recommend changing the number of threads for the worker thread pool.
How to do this is shown in the following sample:</p>
</div>
<div id="_tabs_7" class="openblock tabs is-loading">
<div class="content">
<div class="ulist tablist">
<ul>
<li id="_tabs_7_configuration_api" class="tab">
<p>Configuration API</p>
</li>
<li id="_tabs_7_spring_boot" class="tab">
<p>Spring Boot</p>
</li>
<li id="_tabs_7_spring_boot_properties" class="tab">
<p>Spring Boot properties</p>
</li>
</ul>
</div>
<div id="_tabs_7_configuration_api--panel" class="tabpanel" aria-labelledby="_tabs_7_configuration_api">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.axonframework.common.AxonThreadFactory;
import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.eventhandling.configuration.EventHandlingComponentsConfigurer;
import org.axonframework.messaging.eventhandling.processing.streaming.pooled.PooledStreamingEventProcessorsConfigurer;

import java.util.concurrent.Executors;

public class AxonConfig {

    public void configureEventProcessing(MessagingConfigurer configurer) {
        configurer.eventProcessing(eventConfigurer -&gt; eventConfigurer.pooledStreaming(
                this::configurePooledStreamingProcessor
        ));
    }

    private PooledStreamingEventProcessorsConfigurer configurePooledStreamingProcessor(
            PooledStreamingEventProcessorsConfigurer pooledStreamingConfigurer
    ) {
        return pooledStreamingConfigurer.processor(
                "example-processor",
                config -&gt; config.eventHandlingComponents(this::configureHandlingComponent).customized(
                        (c, psepConfig) -&gt; psepConfig.coordinatorExecutor(Executors.newScheduledThreadPool(
                                                             1, new AxonThreadFactory("Coordinator - example-processor")
                                                     ))
                                                     .workerExecutor(Executors.newScheduledThreadPool(
                                                             16, new AxonThreadFactory("Worker - example-processor")
                                                     ))
                )
        );
    }
}</code></pre>
</div>
</div>
</div>
<div id="_tabs_7_spring_boot--panel" class="tabpanel" aria-labelledby="_tabs_7_spring_boot">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// TODO #4053 - Introduce Event Processor Specification bean example.</code></pre>
</div>
</div>
</div>
<div id="_tabs_7_spring_boot_properties--panel" class="tabpanel" aria-labelledby="_tabs_7_spring_boot_properties">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">axon.eventhandling.processors.example-processor.mode=pooled-streaming
# Only the thread count of the Worker can be influenced through a properties file!
axon.eventhandling.processors.example-processor.thread-count=16
axon.eventhandling.processors.example-processor.initial-segment-count=32</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="multi_node_processing"><a class="anchor" href="#multi_node_processing"></a>Multi-node processing</h3>
<div class="paragraph">
<p>For streaming processors, it doesn&#8217;t matter whether the threads handling the events are all running on the same node or on different nodes hosting the same (logical) processor.
When two (or more) instances of a streaming processor with the same name are active on different machines, they are considered two instances of the same logical processor.
Hence, it is not just a processor&#8217;s own threads that compete for segments but also the processors on different application instances.</p>
</div>
<div class="paragraph">
<p>Thus, in a multi-node setup, each processor instance will try to <a href="#parallel_processing">claim segments</a>, preventing events assigned to that segment from being processed on other nodes.
In this process, the processor updates the token by adding a node identifier when it claims a segment to enforce the claim.
The node identifier is configurable on the <code>TokenStore</code>.
By default, it will use the JVM&#8217;s name (usually a combination of the hostname and process ID) as the <code>nodeId</code>.</p>
</div>
<div class="paragraph">
<p>In a multi-node scenario, a fair distribution of the segments is often desired.
Otherwise, the event processing load could be distributed unequally over the active instances.
There are roughly four approaches to balancing the number of segments claimed per node:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Connecting your Axon Framework application to <a href="../../../../../axoniq-platform-reference/" class="xref page">Axoniq Platform</a> and enabling automated segment &amp; thread scaling.</p>
</li>
<li>
<p>Through the <a href="../../../../../axon-server-reference/development/" class="xref page">Axon Server</a> Dashboard&#8217;s load balancing feature.</p>
</li>
<li>
<p>For Axon Server and Spring Boot users, you can use the <code>axon.axonserver.eventhandling.processors.[processor-name].load-balancing-strategy</code> application property.</p>
</li>
<li>
<p>Directly on a <code>StreamingEventProcessor</code>, with the <code>releaseSegment(int segmentId)</code> or <code>releaseSegment(int segmentId, long releaseDuration, TimeUnit unit)</code> method.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By far the simplest approach is to connect your application to Axoniq Platform, as it provides the most flexibility.</p>
</div>
<div class="paragraph">
<p>When Axon Server but not Axoniq Platform is in place, we recommend using either option two or three.
Where option two requires access to the dashboard before load balancing is activated, option three works from within your framework application&#8217;s properties file.
For those looking to configure load balancing through option three, please consider the following <code>application.properties</code> file example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># Enables automatic balancing for event processor "example-processor."
# Setting automatic balancing to true causes Axon Server to periodically check whether the segments are balanced.
# Note that automatic balancing is an Enterprise feature of Axon Server.
axon.axonserver.eventhandling.processors.example-processor.automatic-balancing=true
# Set the load balancing strategy to, for example, "threadNumber."
# Note that this task is executed only once, on the start up of the Axon Framework application.
axon.axonserver.eventhandling.processors.example-processor.load-balancing-strategy=threadNumber</code></pre>
</div>
</div>
<div class="paragraph">
<p>When neither Axoniq Platform nor Axon Server are used, we can achieve load balancing by having a streaming processor release its segments.
Releasing segments is done by calling the <code>releaseSegment</code> method.
When invoking <code>releaseSegment</code>, the <code>StreamingEventProcessor</code> will "let go of" the segment for some time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.axonframework.common.configuration.Configuration;
import org.axonframework.messaging.eventhandling.processing.streaming.StreamingEventProcessor;

import java.util.Map;
import java.util.concurrent.CompletableFuture;

class StreamingProcessorService {

    // The Configuration allows access to all the configured EventProcessors
    private Configuration configuration;

    CompletableFuture&lt;Void&gt; releaseSegmentFor(String processorName, int segmentId) {
        Map&lt;String, StreamingEventProcessor&gt; processors = configuration.getComponents(StreamingEventProcessor.class);
        return processors.get(processorName)
                         .releaseSegment(segmentId);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="splitting_and_merging_segments"><a class="anchor" href="#splitting_and_merging_segments"></a>Splitting and merging segments</h3>
<div class="paragraph">
<p>The Streaming Event Processor provides scalability by supporting <a href="#parallel_processing">parallel processing</a>.
Through this, it is possible to tune the processor&#8217;s performance by <a href="#thread_configuration">adjusting the number of threads</a>.
However, only changing the number of threads is insufficient since the parallelization is dictated through the number of segments.</p>
</div>
<div class="paragraph">
<p>When there is a high event load, ideally, we increase the number of segments.
In turn, we can reduce the number of segments again if the load on the streaming processor decreases.
To change the number of segments at runtime, the <em>split and merge</em> operations should be used.
Splitting and merging allow you to control the number of segments dynamically.
There are roughly three approaches to do this.</p>
</div>
<div class="sect3">
<h4 id="_axoniq_platform"><a class="anchor" href="#_axoniq_platform"></a>Axoniq Platform</h4>
<div class="paragraph">
<p>Through <a href="../../../../../axoniq-platform-reference/" class="xref page">Axoniq Platform</a>'s processor detail page, where you can scale the segments manually, or configure your segments to scale automatically with the number of your application&#8217;s replicas.
It&#8217;s the easiest to set up and use.</p>
</div>
</div>
<div class="sect3">
<h4 id="_axon_server"><a class="anchor" href="#_axon_server"></a>Axon Server</h4>
<div class="paragraph">
<p>The <a href="../../../../../axon-server-reference/development/" class="xref page">Axon Server</a> Dashboard contains split and merge buttons to adjust the number of segments.
While it&#8217;s straightforward to use as well, it does not support automatic scaling based on the number of replicas.</p>
</div>
</div>
<div class="sect3">
<h4 id="_manual_programming"><a class="anchor" href="#_manual_programming"></a>Manual programming</h4>
<div class="paragraph">
<p>If none of the other two options are available, you can adjust the number of segments through the Axon Framework API.
The <code>StreamingEventProcessor</code> exposes the <code>splitSegment(int segmentId)</code> and <code>mergeSegment(int segmentId)</code> methods.
To obtain the <code>StreamingEventProcessor</code>, you can use the <code>EventProcessingConfiguration</code> to retrieve the processor by name.</p>
</div>
<div class="paragraph">
<p>For those taking this approach, consider the following snippet as a form of guidance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.axonframework.common.configuration.Configuration;
import org.axonframework.messaging.eventhandling.processing.streaming.StreamingEventProcessor;

import java.util.Map;
import java.util.concurrent.CompletableFuture;

class StreamingProcessorService {

    // The Configuration allows access to all the configured EventProcessors
    private Configuration configuration;

    CompletableFuture&lt;Boolean&gt; splitSegmentFor(String processorName, int segmentId) {
        Map&lt;String, StreamingEventProcessor&gt; processors = configuration.getComponents(StreamingEventProcessor.class);
        return processors.get(processorName)
                         .splitSegment(segmentId);
    }

    CompletableFuture&lt;Boolean&gt; mergeSegmentFor(String processorName, int segmentId) {
        Map&lt;String, StreamingEventProcessor&gt; processors = configuration.getComponents(StreamingEventProcessor.class);
        return processors.get(processorName)
                         .mergeSegment(segmentId);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that if you are moving towards a solution using the <code>StreamingProcessorService</code>, there are a couple of points to consider.
When invoking the split/merge operation on a <code>StreamingEventProcessor</code>, that processor should be in charge of the segment you want to split or merge.
Thus, either the streaming processor already has a claim on the segments or can claim the segments.
Without the claims, the processor will simply fail the split or merge operation.</p>
</div>
<div class="paragraph">
<p>It is advised to check which segments a streaming processor has a claim on.
For that, <a href="../../../monitoring/processors/#event-tracker-status" class="xref page">status of the processor</a> is used.
The status information shows which segments a processor instance owns.
This guides which processor to invoke the split or merge on.</p>
</div>
<div class="paragraph">
<p>When doing a merge, the streaming processor should be in charge of <strong>both</strong> the provided <code>segmentId</code> and the segment the framework will merge it with.
We can calculate the segment identifier the provided <code>segmentId will be merged with through the`Segment#mergeableSegmentId</code> method.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Segment Selection Considerations</div>
<div class="paragraph">
<p>When splitting or merging through Axoniq Platform and Axon Server, it chooses the most appropriate segment to split or merge for you.
When using the Axon Framework API directly, the developer should deduce the segment to split or segments to merge by themselves:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Split: for fair balancing, a split is ideally performed on the largest segment</p>
</li>
<li>
<p>Merge: for fair balancing, a merge is ideally performed on the smallest segment</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We recommend Axoniq Platform or Axon Server because there&#8217;s a lot to take into account when taking the latter approach.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="replaying-events"><a class="anchor" href="#replaying-events"></a>Replaying events</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="title">Replaying events not available in Axon Framework 5.0</div>
<div class="paragraph">
<p>The Replaying events feature is not yet available in Axon Framework 5.0.
It will be reintroduced in Axon Framework 5.1.
The documentation below describes the Replaying events concepts for reference and future use.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A benefit of streaming events is that we can reopen the stream at any point in time.
Whenever some event handling components misbehaved, and the view models they update or actions they triggered should happen again, starting anew can be useful.
Handling events again by adjusting the position on the stream is what&#8217;s called "a replay," a feature supported by the <code>StreamingEventProcessor</code>.
You can trigger a reset using <a href="../../../../../axoniq-platform-reference/" class="xref page">Axoniq Platform</a>, or programmatically through the Axon Framework API.</p>
</div>
<div class="sect2">
<h3 id="reset-console"><a class="anchor" href="#reset-console"></a>Triggering a reset with Axoniq Platform</h3>
<div class="paragraph">
<p>Triggering a reset through the <a href="../../../../../axoniq-platform-reference/" class="xref page">Axoniq Platform</a> is straightforward.
It will make sure all processors are stopped, the tokens reset, and the replay is started, without any need for manual intervention.</p>
</div>
<div class="paragraph">
<p>Go to the detail page of the processor you would like to reset.
On the left side, under the configuration details, is a "Reset Processor" button.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../_images/console-processor-detail-page-reset.png" alt="Axoniq Platform processor detail page with underlined 'Reset Processor' button">
</div>
</div>
<div class="paragraph">
<p>Clicking this button will open a dialog in which you can choose the desired position in the event store to replay from.
You can choose to reset to the first position (beginning), latest position (end), or a custom date.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../../_images/console-processor-reset-dialog.png" alt="Axoniq Platform reset dialog" width="65%">
</div>
</div>
<div class="paragraph">
<p>After resetting the processor, the replay will start immediately.
You can track its progress under the "Segments" tab.
During a replay, each segment has its own pace.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../_images/console-processor-replaying-segments.png" alt="Axoniq Platform segments view during a replay">
</div>
</div>
<div class="paragraph">
<p>During this time, it&#8217;s normal to see the latency of the processor at a high value, because it&#8217;s processing events from a long time ago.
This will slowly decrease until it&#8217;s back at the latest position.</p>
</div>
</div>
<div class="sect2">
<h3 id="reset-programmatically"><a class="anchor" href="#reset-programmatically"></a>Triggering a reset programmatically</h3>
<div class="paragraph">
<p>You can also trigger a reset using the Axon Framework API.
This API revolves around the <code>resetTokens()</code> method and provides a couple of options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>resetTokens()</code>: Simple reset, adjusting the <code>TrackingToken</code> to the configured <a href="#initial_token">initial tracking token</a></p>
</li>
<li>
<p><code>resetTokens(R resetContext)</code>: Resets the <code>TrackingToken</code> to the configured <a href="#initial_token">initial tracking token</a>, providing the <code>resetContext</code> to the <a href="#_replay_api"><code>ResetHandlers</code></a></p>
</li>
<li>
<p><code>resetTokens(Function&lt;TrackingTokenSource&gt;, CompletableFuture&lt;TrackingToken&gt;&gt; initialTrackingTokenSupplier)</code>: Resets the <code>TrackingToken</code> to the results of the <code>initialTrackingTokenSupplier</code></p>
</li>
<li>
<p><code>resetTokens(Function&lt;TrackingTokenSource&gt;, CompletableFuture&lt;TrackingToken&gt;&gt; initialTrackingTokenSupplier, R resetContext)</code>: Resets the <code>TrackingToken</code> to the results of the <code>initialTrackingTokenSupplier</code>, providing the <code>resetContext</code> to the <a href="#_replay_api"><code>ResetHandlers</code></a></p>
</li>
<li>
<p><code>resetTokens(TrackingToken startPosition)</code>: Resets the <code>TrackingToken</code> to the provided <code>startPosition</code></p>
</li>
<li>
<p><code>resetTokens(TrackingToken startPosition, R resetContext)</code>: Resets the <code>TrackingToken</code> to the provided <code>startPosition</code>, providing the <code>resetContext</code> to the <a href="#_replay_api"><code>ResetHandlers</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All methods above return a <code>CompletableFuture&lt;Void&gt;</code> that will signal if the reset was triggered successfully or exceptionally.
As the method name suggests, the reset adjusts the <a href="#tracking_tokens">tracking token</a> to a new position.
When starting a reset, the streaming processor is <em>required</em> to claim all its <a href="#parallel_processing">segments</a>.
All claims are required since the processor needs to update all tokens to their new position to start the replay.</p>
</div>
<div class="paragraph">
<p>To achieve this, the streaming event processor must be inactive when starting a reset.
Hence, it is required to be shut down first before invoking the <code>resetTokens</code> operation.
Once the reset was successful, the processor can be started up again.</p>
</div>
<div class="paragraph">
<p>Consider the following sample on how to trigger a reset within an application:</p>
</div>
<div id="_tabs_8" class="openblock tabs is-loading">
<div class="content">
<div class="ulist tablist">
<ul>
<li id="_tabs_8_reset_without_reset_context" class="tab">
<p>Reset without reset context</p>
</li>
<li id="_tabs_8_reset_with_reset_context" class="tab">
<p>Reset with reset context</p>
</li>
</ul>
</div>
<div id="_tabs_8_reset_without_reset_context--panel" class="tabpanel" aria-labelledby="_tabs_8_reset_without_reset_context">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.axonframework.common.configuration.Configuration;
import org.axonframework.messaging.eventhandling.processing.streaming.StreamingEventProcessor;

import java.util.Map;
import java.util.concurrent.CompletableFuture;

class StreamingProcessorService {

    // The Configuration allows access to all the configured EventProcessors
    private Configuration configuration;

    CompletableFuture&lt;CompletableFuture&lt;Void&gt;&gt; resetTokensFor(String processorName) {
        Map&lt;String, StreamingEventProcessor&gt; processors = configuration.getComponents(StreamingEventProcessor.class);
        StreamingEventProcessor processor = processors.get(processorName);
        // shutdown this streaming processor
        return processor.shutdown()
                        // reset the tokens to prepare the processor
                        .thenApply(result -&gt; processor.resetTokens())
                        // start the processor to initiate the replay
                        .thenApply(result -&gt; processor.start());
    }
}</code></pre>
</div>
</div>
</div>
<div id="_tabs_8_reset_with_reset_context--panel" class="tabpanel" aria-labelledby="_tabs_8_reset_with_reset_context">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.axonframework.common.configuration.Configuration;
import org.axonframework.messaging.eventhandling.processing.streaming.StreamingEventProcessor;

import java.util.Map;
import java.util.concurrent.CompletableFuture;

class StreamingProcessorService {

    // The Configuration allows access to all the configured EventProcessors
    private Configuration configuration;

    CompletableFuture&lt;CompletableFuture&lt;Void&gt;&gt; resetTokensFor(String processorName,
                                                              Object resetContext) {
        Map&lt;String, StreamingEventProcessor&gt; processors = configuration.getComponents(StreamingEventProcessor.class);
        StreamingEventProcessor processor = processors.get(processorName);
        // shutdown this streaming processor
        return processor.shutdown()
                        // reset the tokens to prepare the processor
                        .thenApply(result -&gt; processor.resetTokens(resetContext))
                        // start the processor to initiate the replay
                        .thenApply(result -&gt; processor.start());
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="title">Resets in multi-node environments</div>
<div class="paragraph">
<p>If you are in a <a href="#multi_node_processing">multi-node</a> scenario, that means <em>all</em> nodes should shut down the <code>StreamingEventProcessor</code>.
Otherwise, another node will pick up the segments released by the inactive processor instance.</p>
</div>
<div class="paragraph">
<p>Being able to shut down or start up all streaming processor instances is most easily achieved through <a href="../../../../../axoniq-platform-reference/" class="xref page">Axoniq Platform</a> or <a href="../../../../../axon-server-reference/development/" class="xref page">Axon Server</a>.
They both provide a "start" and "stop" button, which will start/stop the processor on every node.
With Axoniq Platform you can also reset the processor.</p>
</div>
<div class="paragraph">
<p>When Axon Server is not used, you should construct a custom endpoint in your application.
The <code>StreamingProcessorService</code> sample shared above would be ideal for adding a start and stop method.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_partial_replays"><a class="anchor" href="#_partial_replays"></a>Partial replays</h4>
<div class="paragraph">
<p>A replay does not always have to start "from the beginning of time." Partially replaying the event stream suffices for a lot of applications.</p>
</div>
<div class="paragraph">
<p>To perform a so-called "partial replay," you should provide the token at a specific point in time.
The <code>StreamableEventSource&#8217;s <a href="#initial_token">`createTokenAt(Instant)</code></a> method can be used for this.</p>
</div>
<div class="paragraph">
<p>If creating tokens based on time is not sufficient, but creating tokens based on the exact position is something that is more convenient, you could create a <code>TrackingToken</code> providing the position and give it to <code>resetTokens(TrackingToken startPosition)</code> or
<code>resetTokens(TrackingToken startPosition, R resetContext)</code>.
The concrete implementation of <code>TrackingToken</code> to provide depends on the <code>TokenStore</code> being used.
Or, if you want to use the token source for your Streaming Processor to construct the right type of token in one go, you can use the  <code>resetTokens(Function&lt;TrackingTokenSource&gt;, CompletableFuture&lt;TrackingToken&gt;&gt; initialTrackingTokenSupplier)</code> or
<code>resetTokens(Function&lt;TrackingTokenSource&gt;, CompletableFuture&lt;TrackingToken&gt;&gt; initialTrackingTokenSupplier, R resetContext)</code> methods.</p>
</div>
<div class="paragraph">
<p>Be mindful that when initiating a partial replay, the event handlers may handle an event in the middle of model construction.
Hence, event handlers need to be "aware" that some events might not have been handled at all.
Making the event handlers lenient (for example, deal with missing data) or performing ad-hoc manual replays are avenues to pursue to resolve this.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_replay_api"><a class="anchor" href="#_replay_api"></a>Replay API</h3>
<div class="paragraph">
<p>Initiating a replay through the <code>StreamingEventProcessor</code> opens up an API to tap into the process of replaying.
It is, for example, possible to define a <code>@ResetHandler</code>, which provides a hook to prepare an Event Handling Component before the replay begins.
A processor will invoke <code>ResetHandler</code> annotated methods as a result of <code>StreamingEventProcessor#resetTokens</code>.</p>
</div>
<div class="paragraph">
<p>During a reset through the <code>StreamingEventProcessor#resetTokens</code> API, you can supply a <code>resetContext</code> parameter.
This context is supplied to <code>@ResetHandler</code> annotated methods and saved in the <code>ReplayToken</code>.
This context can, for the duration of the replay, be accessed using the <code>ReplayToken.replayContext</code> methods or can be injected into event handlers using the <code>@ReplayContext</code> annotation.</p>
</div>
<div class="paragraph">
<p>The following sample Event Handling Component shows the available replay API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AllowReplay <i class="conum" data-value="1"></i><b>(1)</b>
@ProcessingGroup("card-summary")
public class CardSummaryProjection {
    //...
    @EventHandler
    @DisallowReplay <i class="conum" data-value="2"></i><b>(2)</b>
    public void on(CardIssuedEvent event) {
        // This event handler performs a "side effect",
        //  like sending an e-mail or a sms.
        // Neither, is something we want to reoccur when a
        //  replay happens, hence we disallow this method
        //  to be replayed
    }

    @EventHandler
    public void on(CardRedeemedEvent event, ReplayStatus replayStatus) { <i class="conum" data-value="3"></i><b>(3)</b>
        // We can wire a ReplayStatus here so we can see whether this
        // event is delivered to our handler as a 'REGULAR' event or
        // a 'REPLAY' event
        // Perform event handling
    }

    @ResetHandler <i class="conum" data-value="4"></i><b>(4)</b>
    public void onReset(ResetContext resetContext) {
        // Do pre-reset logic, like clearing out the projection table for a
        // clean slate. The given resetContext is [optional], allowing the
        // user to specify in what context a reset was executed.
    }

    @EventHandler
    public void on(CardCancelledEvent event, @ReplayContext CardReplayContext context) { <i class="conum" data-value="5"></i><b>(5)</b>
        // During replays, this method will get the CardReplayContext injected that was providing during the reset call.
        // If there is no replay, no context was supplied or the context type does not match, the parameter is null.
    }
    //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>CardSummaryProjection</code> shows a couple of interesting things to take note of when it comes to "being aware" of a replay in progress:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>An <code>@AllowReplay</code> can be used, situated either on an entire class or an <code>@EventHandler</code> annotated method.
It defines whether the processor should invoke the given class or method when a replay is in transit.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>In addition to allowing a replay, <code>@DisallowReplay</code> can also be used.
Similar to <code>@AllowReplay</code>, you can place it on class level and methods.
It serves to define whether a processor should <strong>not</strong> invoke the class or method when a replay is in transit.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>To have more fine-grained control on what (not) to do during a replay, we can use the <code>ReplayStatus</code> parameter.
The <code>ReplayStatus</code> is an additional parameter that we can add to <code>@EventHandler</code> annotated methods.
It allows conditional operations in the event handlers based on whether a replay is taking place.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>If it is necessary to perform certain pre-replay logic, such as clearing out a projection table, we can use the <code>@ResetHandler</code> annotation.
It allows adding a "reset context" to provide more information on why the reset is taking place.
To include a <code>resetContext</code> the <code>resetTokens(R resetContext)</code> method (or other methods containing the <code>resetContext</code> parameter) should be invoked.
The type of the <code>resetContext</code> is up to the user.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>If it is necessary to use information that was available at time of calling <code>resetTokens(R resetContext)</code> in your event handlers during a replay, you can use the <code>@ReplayContext</code> annotation to get access to this information.
This information is stored in the <code>ReplayToken</code> and will be available until the end of the replay.
The type of the <code>resetContext</code> is up to the user and is the same context as is used for the <code>@ResetHandler</code> (see 4).
The type of the <code>resetContext</code> has to match the parameter&#8217;s, or it will be null.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If users take the declarative configuration process instead of auto-detecting through annotation, you should wrap your <code>EventHandlingComponent</code> in an <code>ReplayBlockingEventHandlingComponent</code>.
This will ensure all subscribed event handlers for that event handling component will not be invoked during a replay:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.axonframework.messaging.core.MessageStream;
import org.axonframework.messaging.core.QualifiedName;
import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.eventhandling.EventHandlingComponent;
import org.axonframework.messaging.eventhandling.SimpleEventHandlingComponent;
import org.axonframework.messaging.eventhandling.configuration.EventHandlingComponentsConfigurer;
import org.axonframework.messaging.eventhandling.processing.streaming.pooled.PooledStreamingEventProcessorsConfigurer;
import org.axonframework.messaging.eventhandling.replay.ReplayBlockingEventHandlingComponent;

public class AxonConfig {

    public void configureEventProcessing(MessagingConfigurer configurer) {
        configurer.eventProcessing(eventConfigurer -&gt; eventConfigurer.pooledStreaming(
                this::configurePooledStreamingProcessor
        ));
    }

    private PooledStreamingEventProcessorsConfigurer configurePooledStreamingProcessor(
            PooledStreamingEventProcessorsConfigurer pooledStreamingConfigurer
    ) {
        return pooledStreamingConfigurer.processor(
                "example-processor",
                config -&gt; config.eventHandlingComponents(this::configureHandlingComponent).notCustomized()
        );
    }

    private EventHandlingComponentsConfigurer.AdditionalComponentPhase configureHandlingComponent(
            EventHandlingComponentsConfigurer.RequiredComponentPhase componentConfigurer
    ) {
        return componentConfigurer.declarative(c -&gt; {
            EventHandlingComponent eventHandlingComponent =
                    new ReplayBlockingEventHandlingComponent(new SimpleEventHandlingComponent());
            eventHandlingComponent.subscribe(
                    new QualifiedName("test-event"),
                    (event, context) -&gt; {
                        // process events
                        return MessageStream.empty();
                    }
            );
            return eventHandlingComponent;
        });
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_multiple_event_sources"><a class="anchor" href="#_multiple_event_sources"></a>Multiple event sources</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="title">Multiple event sources not available in Axon Framework 5.0</div>
<div class="paragraph">
<p>The <code>MultiStreamableEventSource</code> feature is not yet available in Axon Framework 5.0.
It will be reintroduced in Axon Framework 5.2.0.
The documentation below describes the multiple event sources concepts for reference and future use.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can configure a Streaming Event Processor to use multiple sources to process events from.
When required to process events from several sources, we can configure a specific type of <code>StreamableEventSource</code>: the <code>MultiStreamableEventSource</code>.
The <code>MultiStreamableEventSource</code> is useful when a streaming processor should act on the events from:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>several event stores,</p>
</li>
<li>
<p><a href="../../../../../axon-server-reference/development/axon-server/administration/multi-context/" class="xref page">multiple-contexts</a>, or</p>
</li>
<li>
<p>from different storage types (for example, an Event Store and a Kafka Stream)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Having multiple sources means that there might be a choice of multiple events that the processor could consume at any given instant.
Therefore, you can specify a <code>Comparator</code> to choose between them.
The default implementation chooses the event with the oldest timestamp (that is, the event waiting for the longest).</p>
</div>
<div class="paragraph">
<p>Using multiple sources also means that the streaming processor&#8217;s polling interval needs to be divided between sources.
Some sources might use a strategy to optimize event discovery, thus minimizing overhead in establishing costly connections to the data sources.
To that end, you can choose which source the processor does most of the polling on using the <code>longPollingSource()</code> method in the builder.
This operation ensures one source consumes most of the polling interval while also checking intermittently for events on the other sources.
The <code>MultiStreamableEventSource</code> defaults the <code>longPollingSource</code> to the last configured source.</p>
</div>
<div class="paragraph">
<p>Consider the following sample when constructing a <code>MultiStreamableEventSource</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class AxonConfig {
    // omitting other configuration methods...
    public MultiStreamableEventSource buildMultiStreamableEventSource(
            StreamableEventSource&lt;TrackedEventMessage&lt;?&gt;&gt; eventSourceA,
            StreamableEventSource&lt;TrackedEventMessage&lt;?&gt;&gt; eventSourceB,
            Comparator&lt;Map.Entry&lt;String, TrackedEventMessage&lt;?&gt;&gt;&gt; priorityA
    ) {
        return MultiStreamableEventSource.builder()
                                           .addMessageSource("eventSourceA", eventSourceA)
                                           .addMessageSource("eventSourceB", eventSourceB)
                                           .longPollingSource("eventSourceA") // Overrides eventSourceB as the longPollingStream
                                           .trackedEventComparator(priorityA) // Where 'priorityA' is a comparator prioritizing events from eventSourceA
                                           .build();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assuming a <code>buildMultiStreamableEventSource(&#8230;&#8203;)</code> method is present, we can use the outcome to register a processor with the configuring <code>EventProcessingConfigurer</code>:</p>
</div>
<div id="_tabs_9" class="openblock tabs is-loading">
<div class="content">
<div class="ulist tablist">
<ul>
<li id="_tabs_9_tracking_configuration_api" class="tab">
<p>Tracking: Configuration API</p>
</li>
<li id="_tabs_9_tracking_spring_boot" class="tab">
<p>Tracking: Spring Boot</p>
</li>
<li id="_tabs_9_pooled_streaming_configuration_api" class="tab">
<p>Pooled streaming: Configuration API</p>
</li>
<li id="_tabs_9_pooled_streaming_spring_boot" class="tab">
<p>Pooled streaming: Spring Boot</p>
</li>
<li id="_tabs_9_spring_boot_properties" class="tab">
<p>Spring Boot properties</p>
</li>
</ul>
</div>
<div id="_tabs_9_tracking_configuration_api--panel" class="tabpanel" aria-labelledby="_tabs_9_tracking_configuration_api">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class AxonConfig {
    // omitting other configuration methods...
    public void configureTrackingProcessor(EventProcessingConfigurer processingConfigurer) {
        processingConfigurer.registerTrackingEventProcessor(
                "example-processor", config -&gt; buildMultiStreamableEventSource(/*...*/)
        );
    }
}</code></pre>
</div>
</div>
</div>
<div id="_tabs_9_tracking_spring_boot--panel" class="tabpanel" aria-labelledby="_tabs_9_tracking_spring_boot">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// TODO #4053 - Introduce Event Processor Specification bean example.</code></pre>
</div>
</div>
</div>
<div id="_tabs_9_pooled_streaming_configuration_api--panel" class="tabpanel" aria-labelledby="_tabs_9_pooled_streaming_configuration_api">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class AxonConfig {
    // omitting other configuration methods...
    public void configurePooledStreamingProcessor(EventProcessingConfigurer processingConfigurer) {
        processingConfigurer.registerPooledStreamingEventProcessor(
                "example-processor", config -&gt; buildMultiStreamableEventSource(/*...*/)
        );
    }
}</code></pre>
</div>
</div>
</div>
<div id="_tabs_9_pooled_streaming_spring_boot--panel" class="tabpanel" aria-labelledby="_tabs_9_pooled_streaming_spring_boot">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// TODO #4053 - Introduce Event Processor Specification bean example.</code></pre>
</div>
</div>
</div>
<div id="_tabs_9_spring_boot_properties--panel" class="tabpanel" aria-labelledby="_tabs_9_spring_boot_properties">
<div class="paragraph">
<p>When we want to configure the <code>StreamableEventSource</code> in a properties file, we should provide a bean name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">axon.eventhandling.processors.example-processor.mode=pooled-streaming
axon.eventhandling.processors.example-processor.source=multiStreamableEventSource</code></pre>
</div>
</div>
<div class="paragraph">
<p>This approach does require the bean name to be present in the Application Context of course:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class AxonConfig {
    // omitting other configuration methods...
    @Bean
    public MultiStreamableEventSource multiStreamableEventSource(
            StreamableEventSource&lt;TrackedEventMessage&lt;?&gt;&gt; eventSourceA,
            StreamableEventSource&lt;TrackedEventMessage&lt;?&gt;&gt; eventSourceB,
            Comparator&lt;Map.Entry&lt;String, TrackedEventMessage&lt;?&gt;&gt;&gt; priorityA
    ) {
        return MultiStreamableEventSource.builder()
                                           .addMessageSource("eventSourceA", eventSourceA)
                                           .addMessageSource("eventSourceB", eventSourceB)
                                           .longPollingSource("eventSourceA")
                                           .trackedEventComparator(priorityA)
                                           .build();
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
        <nav class="pagination">
  <span class="prev"><a href="../subscribing/">Subscribing Event Processor</a></span>
  <span class="next"><a href="../dead-letter-queue/">Dead-Letter Queue</a></span>
</nav>
    </article>
  </div>
</main>
</div>
      <footer class="footer">
  <div class="secondary-footer">
    <p>Copyright Â© 2025 AxonIQ BV. All Rights Reserved</p>
    <img referrerpolicy="no-referrer-when-downgrade" src="https://static.scarf.sh/a.png?x-pxid=e0b2b5cb-139e-4753-acab-bae43f90c5d3" />
  </div>
</footer>
<script id="site-script" src="../../../../../_/js/site.js" data-ui-root-path="../../../../../_"></script>
<script async src="../../../../../_/js/vendor/highlight.js"></script>
<script async src="../../../../../_/js/vendor/page-actions.js"></script>
<script async src="../../../../../_/js/vendor/tabs.js" data-sync-storage-key="preferred-tab" data-sync-storage-scope="session"></script>
<script src="../../../../../_/js/vendor/lunr.js"></script>
<script src="../../../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../../../.." data-snippet-length="100" data-stylesheet="../../../../../_/css/search.css"></script>
<script async src="../../../../../search-index.js"></script>
    </div>
  </body>
</html>
