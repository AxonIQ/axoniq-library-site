= Message-Driven Architecture
:page-needs-improvement: content
:page-needs-content: This page is a placeholder. Add meaningful content.

== Overview

=== Combining DDD with CQRS

When combining DDD and CQRS, one divides an application into components, where each component either provides information about the application's state, or that changes the application's state. Each of these components have a model that focuses on these responsibilities.

The image below shows a typical architecture of an Axon based application.

![Architecture overview of a CQRS based Axon application](../.gitbook/assets/cqrs-ddd-eda.png)

In such an architecture, a UI \(or API\) can send commands to request to change an application's state.
These Commands are handled by a Command Handling Component, which uses a model to validate the command and make decisions on which side-effects to trigger \(if any\).

The side-effects caused by commands are published using events.
These events are persisted into the Event Store, after which they become available to the Event Handling Components.
These will, in turn, take their appropriate action.

A typical action is updating the view models, which for example allow the UI to render the application's state.
Other actions could be sending messages to external components, or even triggering other side-effects through new commands.

To retrieve the required information from the query model, the UI (or API) can send queries to their respective Query Handling Components.
The Query Handling Components in turn respond by returning sections of the query model as dedicated query responses.

The separation of the Command Model and the Query Models \(also called View Models or Projections\) allows these models to only focus on that specific aspect of the application.
This makes each individual model easier to comprehend, and therefore more maintainable in the long term.

=== Explicit Messaging

Axon strongly leverages the use of explicit message objects. This means that each Message in an Axon based application will generally be represented by a specific Java Class in that application. While this does create a little overhead in writing an Axon based application, it does come with a few advantages:

* The use of explicit messages makes it easier to transparently distribute them to remote components;
* The use of explicit messages puts an emphasis on message design, which has proven important in the long-term maintainability of an application;
* Explicit messages can be easily stored for later processing

While Messaging is a core concept in Axon, not all Messages are created equal. Different intents require different routing patterns. For example, for certain message, one would expect a result while others are inherently fire-and-forget.

Axon separates Messages in roughly three categories:

* **Commands**; express the intent to change the application's state. Commands are routed to a single destination and may provide a response.
* **Queries**; express the desire for information. Depending on the dispatch strategy, Queries may be routed to one or more destinations simultaneously.
* **Events**; represent a notification that something relevant has happened. Events are published to any component interested and do not provide any form of return value.

== Benefits
== Message-Driven Architecture in Axon